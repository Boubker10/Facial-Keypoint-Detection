# -*- coding: utf-8 -*-
"""kaggle_reconnaissance.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13dVoyksSj1GOM_FBUvdimDlnoLTH2zvE
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

from PIL import Image
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from sklearn.model_selection import train_test_split

#on commence tout d'abord par unzip le test.zip et training.zip

"!unzip /content/test.zip"
!unzip /content/training.zip

test_df=pd.read_csv("/content/test.csv")
test_df.head(5)

test_df.info()

test_df.describe()

test_df.isna().sum()

"""On peut rien faire pour le fichier test.csv tout le travaille doit se faire pour le fichier training.csv"""

!unzip /content/training.zip

train_df=pd.read_csv("/content/training.csv")
train_df.head(5)

train_df.describe()

train_df.isna().sum()

for i in train_df.columns[:-1]:
  train_df[i].fillna(train_df[i].mean(), inplace=True)

train_df.isna().sum()

def return_img_array(df):
    images=df['Image'].apply(lambda x: np.array(x.split(' '),dtype='int'))
    images=np.stack(images,axis=0).reshape(-1,96,96)/255.0
    return images

# determiner les features de la base de donnée de training
features=train_df.columns[:-1]

#donner le noms des features

features_name=[i.replace('_x','') for n,i in enumerate(features)]
features_name

# on remarque que les features se double donc oin ajoute une condition " n soit pair"

features_name=[i.replace('_x','') for n, i in enumerate(features) if n%2==0]
features_name

train_x=return_img_array(train_df)
train_y=train_df[features]

print(train_x.shape)
print(train_y.shape)

print("pixel par image",train_x.shape[1]*train_x.shape[2])

random_index=np.random.choice(len(train_x))

random_im=train_x[random_index]
plt.imshow(random_im,cmap='gray')
plt.show

def display_grid(rows,cols,x_train,y_train):
    """
    Function that generates the grid of random images where number of rows and
    columns needs to be supplied as arguments to the function.
    """
    plt.figure(figsize=(10,10))
    for i in range(rows*cols):
        random_index=np.random.choice(len(x_train))
        plt.subplot(rows,cols,i+1)
        plt.imshow(x_train[random_index], cmap='gray')
        plt.scatter(y_train[random_index,:,0],y_train[random_index,:,1],marker='x',color='red')
    plt.show()

train_y_reshaped=train_y.values.reshape(train_y.shape[0],15,2)
display_grid(4,4,train_x,train_y_reshaped)

def plot_features(image,feature_names,features_reshaped):
    """
    Function that marks all the facial keypoints on the image with an explanatory
    legend.
    """
    #image=cv2.flip(image,1)
    NUM_COLORS = 15
    cm = plt.get_cmap('gist_rainbow')
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_prop_cycle(color=[cm(1.*i/NUM_COLORS) for i in range(NUM_COLORS)])

    ax.imshow(image, cmap='gray')
    for n, name in enumerate(feature_names):
        ax.scatter(features_reshaped[0,n,0],features_reshaped[0,n,1],marker='x',label=name)
    ax.legend(bbox_to_anchor=(1,1))
    plt.show()

plot_features(train_x[np.random.choice(len(train_x))],features_name,train_y_reshaped)

def create_cnn_model(input_shape):
    model = Sequential()

    # Couche convolutive 1
    model.add(Conv2D(32, (3, 3), activation='relu', input_shape=input_shape))
    model.add(MaxPooling2D((2, 2)))
    model.add(Dropout(0.1))

    # Couche convolutive 2
    model.add(Conv2D(64, (3, 3), activation='relu'))
    model.add(MaxPooling2D((2, 2)))
    model.add(Dropout(0.2))

    # Couche convolutive 3
    model.add(Conv2D(128, (3, 3), activation='relu'))
    model.add(MaxPooling2D((2, 2)))
    model.add(Dropout(0.3))

    # Aplatir et ajouter des couches denses
    model.add(Flatten())
    model.add(Dense(64, activation='relu'))
    model.add(Dropout(0.4))
    model.add(Dense(30))  # 15 points clés * 2 (x, y)

    return model



# Redimensionner train_x pour ajouter une dimension de canal
train_x_reshaped = train_x.reshape(train_x.shape[0], train_x.shape[1], train_x.shape[2], 1)

# Maintenant, créez le modèle avec la forme d'entrée correcte
input_shape = train_x_reshaped.shape[1:]  # Cela devrait être (96, 96, 1)
model = create_cnn_model(input_shape)

# Compilation et entraînement du modèle
model.compile(optimizer='adam', loss='mean_squared_error', metrics=['accuracy'])
history = model.fit(train_x_reshaped, train_y, epochs=150, batch_size=64, validation_split=0.2)

plt.figure(figsize=(12,6))
plt.subplot(1,2,1)
plt.title('Train Dataset')
plt.plot(history.history['loss'],label='train_loss')
plt.plot(history.history['val_loss'],label='validatoin_loss')
plt.legend()
plt.subplot(1,2,2)
plt.title('Validation Dataset')
plt.plot(history.history['accuracy'],label='train_accuracy')
plt.plot(history.history['val_accuracy'],label='validation_accuracy')
plt.legend()
plt.show()

def display_predictions(model, x_data, num_images=1):
    plt.figure(figsize=(10, 10))

    for i in range(num_images):
        # Choisir une image aléatoire
        idx = np.random.choice(len(x_data))
        img = x_data[idx]
        img_reshaped = img.reshape(1, *img.shape)

        # Prédire les points clés
        keypoints = model.predict(img_reshaped)[0].reshape(15, 2)

        # Afficher l'image
        plt.subplot(4, 4, i + 1)
        plt.imshow(img.squeeze(), cmap='gray')  # Squeeze si l'image a un canal supplémentaire
        plt.scatter(keypoints[:, 0], keypoints[:, 1], marker='x', color='red')

    plt.show()


display_predictions(model,train_x)

x_test = return_img_array(test_df)
preds = model.predict(x_test)
print(preds)

x_test_reshaped=preds.reshape(len(preds),15,2)
plot_features(x_test[np.random.choice(len(x_test))],features_name,x_test_reshaped)

import cv2

# Charger l'image
image = cv2.imread("/content/chadli.jpg")  # Remplacez "votre_image.jpg" par le chemin de votre image

# Redimensionner l'image à 96x96 pixels
largeur = 96
hauteur = 96
image_redimensionnee = cv2.resize(image, (largeur, hauteur))

# Enregistrer l'image redimensionnée
cv2.imwrite("image_redimen.jpg", image_redimensionnee)

image_path = '/content/image_redimen.jpg'


image = Image.open(image_path)
image_array = np.array(image)

flattened_image_array = image_array.reshape(-1)


df = pd.DataFrame(flattened_image_array).transpose()
df.insert(0, 'image_id', 1)

csv_file_path = 'youness_as_array.csv'
df.to_csv(csv_file_path, index=False)

za=pd.read_csv("/content/youness_as_array.csv")
za

from PIL import Image
import numpy as np
import pandas as pd

# Remplacez ceci par le chemin de votre image
image_path = '/content/image_redimen.jpg'

# Convertir l'image en nuances de gris
image = Image.open(image_path)
gray_image = image.convert('L')

# Convertir l'image en tableau NumPy et l'aplatir
image_array = np.array(gray_image).flatten()

# Créer la représentation en chaîne de caractères des valeurs de pixels
pixel_str = ' '.join(map(str, image_array))

# Créer un DataFrame avec ImageId et Image
df = pd.DataFrame([{'ImageId': 1, 'Image': pixel_str}])

# Enregistrer le DataFrame dans un fichier CSV
csv_file_path = 'image_data.csv'
df.to_csv(csv_file_path, index=False)

p=pd.read_csv("/content/image_data.csv")
p

x_test = return_img_array(p)
preds = model.predict(x_test)
print(preds)

x_test_reshaped=preds.reshape(len(preds),15,2)
plot_features(x_test[np.random.choice(len(x_test))],features_name,x_test_reshaped)

